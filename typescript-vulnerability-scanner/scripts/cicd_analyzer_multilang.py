#!/usr/bin/env python3
"""
Multi-Language CI/CD Code Analyzer
Analyzes C/C++ and TypeScript/JavaScript code for vulnerabilities
Uses trained ML model - NO LLMs (university compliance)
"""

import sys
import os
import joblib
import numpy as np
import json
from datetime import datetime
from pathlib import Path
from typing import List, Dict, Tuple

# Import feature extractors
sys.path.append(str(Path(__file__).parent))
try:
    from typescript_feature_extractor_v2 import TypeScriptFeatureExtractorV2
except ImportError:
    print("‚ö†Ô∏è  TypeScript feature extractor not found")
    TypeScriptFeatureExtractorV2 = None


class MultiLanguageCodeAnalyzer:
    """
    Analyzes code in multiple languages using ML models
    Supports: C/C++ and TypeScript/JavaScript
    """
    
    def __init__(self, models_dir: Path):
        """Load trained models"""
        self.models_dir = models_dir
        
        # Try to load TypeScript-specific model first (best accuracy for TS)
        ts_model = models_dir / 'typescript_vulnerability_detector.joblib'
        if ts_model.exists():
            print("‚úì Loading TypeScript-specific model...")
            self.ts_model = joblib.load(ts_model)
            self.ts_scaler = joblib.load(models_dir / 'typescript_scaler.joblib')
            self.ts_cwe_encoder = joblib.load(models_dir / 'typescript_cwe_encoder.joblib')
            self.ts_cwe_classifier = joblib.load(models_dir / 'typescript_cwe_classifier.joblib')
            self.ts_feature_extractor = TypeScriptFeatureExtractorV2()
            print(f"‚úì TypeScript model loaded (95% accuracy)")
        else:
            self.ts_model = None
            print("‚ö†Ô∏è  TypeScript model not found")
        
        # Try to load multi-language model as fallback
        multilang_model = models_dir / 'multilang_vulnerability_detector.joblib'
        if multilang_model.exists():
            print("‚úì Loading multi-language model...")
            self.model = joblib.load(multilang_model)
            self.scaler = joblib.load(models_dir / 'multilang_scaler.joblib')
            self.label_encoder = joblib.load(models_dir / 'multilang_cwe_encoder.joblib')
            self.cwe_classifier = joblib.load(models_dir / 'multilang_cwe_classifier.joblib')
            # Create feature extractor locally instead of loading
            if TypeScriptFeatureExtractorV2:
                from train_multilang_model import MultiLanguageFeatureExtractor
                self.feature_extractor = MultiLanguageFeatureExtractor()
            else:
                self.feature_extractor = None
            self.is_multilang = True
            print(f"‚úì Multi-language model loaded (C/C++ + TypeScript)")
        else:
            # Fallback to original C/C++ model
            print("‚úì Loading C/C++ model...")
            self.model = joblib.load(models_dir / 'cicd_vulnerability_detector.joblib')
            self.scaler = joblib.load(models_dir / 'cicd_scaler.joblib')
            self.label_encoder = joblib.load(models_dir / 'cicd_label_encoder.joblib')
            self.feature_extractor = None
            self.cwe_classifier = None
            self.is_multilang = False
            print(f"‚ö†Ô∏è  Multi-language model not found, using C/C++ only")
        
        model_type = "TypeScript (95%)" if self.ts_model else ("Multi-Language (73%)" if self.is_multilang else "C/C++ Only (99.99%)")
        print(f"‚úì Model type: {model_type}")
        if self.ts_model:
            print(f"‚úì TypeScript accuracy: 95.12%")
    
    def detect_language(self, file_path: Path) -> str:
        """Detect programming language from file extension"""
        ext = file_path.suffix.lower()
        
        language_map = {
            '.ts': 'typescript',
            '.tsx': 'typescript',
            '.js': 'javascript',
            '.jsx': 'javascript',
            '.mjs': 'javascript',
            '.c': 'c',
            '.cpp': 'cpp',
            '.cc': 'cpp',
            '.cxx': 'cpp',
            '.h': 'c',
            '.hpp': 'cpp'
        }
        
        return language_map.get(ext, 'unknown')
    
    def extract_features_legacy(self, code: str) -> np.ndarray:
        """Legacy feature extraction for C/C++ (34 features)"""
        import re
        features = []
        
        # Basic metrics
        lines = code.split('\n')
        features.append(len(lines))
        features.append(len(code))
        features.append(code.count('{'))
        features.append(code.count(';'))
        
        # Dangerous functions
        dangerous_patterns = [
            r'\bstrcpy\s*\(', r'\bgets\s*\(', r'\bsprintf\s*\(',
            r'\bstrcat\s*\(', r'\bsystem\s*\(', r'\bexec[vl]?\s*\(',
            r'\bpopen\s*\(', r'\bscanf\s*\(', r'\bmalloc\s*\(',
            r'\bfree\s*\(',
        ]
        for pattern in dangerous_patterns:
            features.append(1 if re.search(pattern, code) else 0)
        
        # Safe functions
        safe_patterns = [
            r'\bstrncpy\s*\(', r'\bfgets\s*\(',
            r'\bsnprintf\s*\(', r'\bstrncat\s*\(',
        ]
        for pattern in safe_patterns:
            features.append(1 if re.search(pattern, code) else 0)
        
        # Sanitization
        features.append(1 if re.search(r'\bvalidate\b', code, re.I) else 0)
        features.append(1 if re.search(r'\bsanitize\b', code, re.I) else 0)
        features.append(1 if re.search(r'\bstrlen\b', code) else 0)
        features.append(1 if re.search(r'\bsizeof\b', code) else 0)
        
        # Pointer operations
        features.append(min(code.count('->'), 50))
        features.append(min(code.count('*'), 50))
        features.append(min(code.count('&'), 50))
        
        # Arrays
        features.append(min(code.count('['), 50))
        features.append(min(code.count(']'), 50))
        
        # Control flow
        features.append(min(code.count('if'), 50))
        features.append(min(code.count('for'), 50))
        features.append(min(code.count('while'), 50))
        
        # Comments
        features.append(min(code.count('//'), 50))
        features.append(min(code.count('/*'), 50))
        
        # Additional
        features.append(min(code.count('NULL'), 20))
        features.append(min(code.count('return'), 20))
        
        return np.array(features, dtype=np.float64).reshape(1, -1)
    
    def analyze_code(self, code: str, language: str) -> Dict:
        """
        Analyze code for vulnerabilities
        
        Returns:
            Dict with classification, confidence, and detected vulnerabilities
        """
        try:
            # Use TypeScript-specific model for TS/JS (best accuracy)
            if language in ['typescript', 'javascript', 'ts', 'js'] and self.ts_model:
                # Extract TypeScript features
                features = self.ts_feature_extractor.extract_features(code)
                features = np.array(features).flatten().reshape(1, -1)
                
                # Scale
                features_scaled = self.ts_scaler.transform(features)
                
                # Predict
                prediction = self.ts_model.predict(features_scaled)[0]
                probabilities = self.ts_model.predict_proba(features_scaled)[0]
                confidence = float(probabilities[prediction]) * 100
                
                # Classify vulnerabilities if detected
                vulnerabilities = []
                if prediction == 1:  # Vulnerable
                    try:
                        cwe_pred = self.ts_cwe_classifier.predict(features_scaled)[0]
                        cwe = self.ts_cwe_encoder.inverse_transform([cwe_pred])[0]
                        
                        # Map CWE to descriptions
                        cwe_descriptions = {
                            'CWE-79': 'XSS via innerHTML',
                            'CWE-89': 'SQL Injection',
                            'CWE-78': 'Command Injection',
                            'CWE-94': 'Code Injection (eval)',
                            'CWE-22': 'Path Traversal'
                        }
                        
                        vulnerabilities.append({
                            'cwe': cwe,
                            'description': cwe_descriptions.get(cwe, 'Unknown vulnerability')
                        })
                    except Exception as e:
                        pass
                
                return {
                    'classification': 'VULNERABLE' if prediction == 1 else 'SAFE',
                    'safe': bool(prediction == 0),
                    'confidence': float(confidence),
                    'vulnerabilities': vulnerabilities,
                    'language': str(language)
                }
            
            elif self.is_multilang and self.feature_extractor:
                # Use multi-language feature extractor
                features = self.feature_extractor.extract_features(code, language)
                
                # Ensure features is a 1D numpy array
                features = np.array(features).flatten()
                
                # Reshape to (1, n_features) for model input
                features = features.reshape(1, -1)
                
                # Scale
                features_scaled = self.scaler.transform(features)
            else:
                # Use legacy C/C++ extractor
                if language not in ['c', 'cpp']:
                    return {
                        'classification': 'UNSUPPORTED',
                        'confidence': 0.0,
                        'language': language,
                        'message': f'Language {language} not supported. Please train multi-language model.'
                    }
                
                features = self.extract_features_legacy(code)
                features_scaled = self.scaler.transform(features)
            
            # Predict
            prediction = int(self.model.predict(features_scaled)[0])
            probabilities = self.model.predict_proba(features_scaled)[0]
            
            # Convert to label
            classification = 'VULNERABLE' if prediction == 1 else 'SAFE'
            confidence = float(probabilities[prediction]) * 100  # Convert to float
            
            # Detect specific CWEs if vulnerable
            vulnerabilities = []
            if classification == 'VULNERABLE':
                vulnerabilities = self._detect_cwes(code, language)
            
            return {
                'classification': str(classification),
                'confidence': float(confidence),
                'language': str(language),
                'vulnerabilities': vulnerabilities,
                'is_vulnerable': bool(classification == 'VULNERABLE')
            }
        except Exception as e:
            import traceback
            print(f"   ‚ö†Ô∏è  Detailed error:")
            print(f"      {traceback.format_exc()}")
            raise
    
    def _detect_cwes(self, code: str, language: str) -> List[str]:
        """Detect specific CWEs in code"""
        cwes = []
        code_lower = code.lower()
        
        if language in ['typescript', 'javascript']:
            # TypeScript/JavaScript CWEs
            if 'innerhtml' in code_lower or 'outerhtml' in code_lower:
                if 'sanitize' not in code_lower:
                    cwes.append('CWE-79: XSS via innerHTML')
            
            if 'eval(' in code_lower:
                cwes.append('CWE-94: Code Injection (eval)')
            
            if 'exec(' in code_lower or 'execsync' in code_lower:
                cwes.append('CWE-78: Command Injection')
            
            # SQL Injection
            if any(kw in code_lower for kw in ['select', 'insert', 'update', 'delete']):
                if '+' in code or '${' in code:
                    if '$1' not in code and '?' not in code:
                        cwes.append('CWE-89: SQL Injection')
            
            # Hard-coded credentials
            if 'password' in code_lower and '=' in code:
                if 'process.env' not in code_lower:
                    cwes.append('CWE-798: Hard-coded Credentials')
            
        else:  # C/C++
            if 'strcpy' in code_lower:
                cwes.append('CWE-787: Buffer Overflow (strcpy)')
            
            if 'gets' in code_lower:
                cwes.append('CWE-676: Dangerous Function (gets)')
            
            if 'sprintf' in code_lower:
                cwes.append('CWE-787: Buffer Overflow (sprintf)')
            
            if 'system(' in code_lower:
                cwes.append('CWE-78: Command Injection (system)')
            
            if 'strcat' in code_lower:
                cwes.append('CWE-120: Buffer Overflow (strcat)')
        
        return cwes
    
    def analyze_files(self, directory: Path) -> Tuple[bool, List[Dict]]:
        """
        Analyze all code files in a directory
        
        Returns:
            (all_safe, analysis_results)
        """
        # Supported extensions
        extensions = ['.c', '.cpp', '.h', '.hpp', '.ts', '.tsx', '.js', '.jsx']
        
        files = []
        for ext in extensions:
            files.extend(directory.rglob(f'*{ext}'))
        
        if not files:
            print(f"‚ö†Ô∏è  No code files found in {directory}")
            return True, []
        
        print(f"üìÇ Found {len(files)} files to analyze")
        
        results = []
        all_safe = True
        
        for file_path in files:
            try:
                language = self.detect_language(file_path)
                
                if language == 'unknown':
                    continue
                
                print(f"\nüîç Analyzing: {file_path.relative_to(directory)} ({language})")
                
                code = file_path.read_text(encoding='utf-8', errors='ignore')
                result = self.analyze_code(code, language)
                result['file'] = str(file_path.relative_to(directory))
                
                results.append(result)
                
                # Print result
                status_icon = '‚úÖ' if result['classification'] == 'SAFE' else '‚ùå'
                print(f"   {status_icon} {result['classification']} ({result['confidence']:.2f}% confidence)")
                
                if result['vulnerabilities']:
                    print(f"   ‚ö†Ô∏è  Vulnerabilities detected:")
                    for vuln in result['vulnerabilities']:
                        print(f"      - {vuln}")
                    all_safe = False
                
            except Exception as e:
                print(f"   ‚ö†Ô∏è  Error analyzing {file_path}: {e}")
                continue
        
        return all_safe, results


def main():
    """Main CI/CD analysis pipeline"""
    if len(sys.argv) != 2:
        print("Usage: python cicd_analyzer_multilang.py <directory>")
        sys.exit(1)
    
    directory = Path(sys.argv[1])
    if not directory.exists():
        print(f"‚ùå Directory not found: {directory}")
        sys.exit(1)
    
    # Determine models directory
    script_dir = Path(__file__).parent
    models_dir = script_dir.parent / 'models'
    reports_dir = script_dir.parent / 'reports'
    
    # Create reports directory if it doesn't exist
    reports_dir.mkdir(exist_ok=True)
    
    if not models_dir.exists():
        print(f"‚ùå Models directory not found: {models_dir}")
        sys.exit(1)
    
    print("=" * 60)
    print("üîç Multi-Language Security Analysis")
    print("=" * 60)
    
    # Load analyzer
    analyzer = MultiLanguageCodeAnalyzer(models_dir)
    
    # Analyze files
    all_safe, results = analyzer.analyze_files(directory)
    
    # Summary
    print("\n" + "=" * 60)
    print("üìä ANALYSIS SUMMARY")
    print("=" * 60)
    print(f"Files analyzed: {len(results)}")
    safe_count = sum(1 for r in results if r['classification'] == 'SAFE')
    vuln_count = sum(1 for r in results if r['classification'] == 'VULNERABLE')
    unsupported_count = sum(1 for r in results if r['classification'] == 'UNSUPPORTED')
    
    print(f"Safe: {safe_count}")
    print(f"Vulnerable: {vuln_count}")
    print(f"Unsupported: {unsupported_count}")
    
    # Save results to reports directory
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    report_name = f"scan_{timestamp}"
    
    # Save JSON report
    json_report = {
        "timestamp": timestamp,
        "directory": str(directory),
        "summary": {
            "total_files": len(results),
            "safe": safe_count,
            "vulnerable": vuln_count,
            "unsupported": unsupported_count,
            "status": "PASSED" if all_safe else "FAILED"
        },
        "results": results
    }
    
    json_path = reports_dir / f"{report_name}.json"
    with open(json_path, 'w', encoding='utf-8') as f:
        json.dump(json_report, f, indent=2, ensure_ascii=False)
    
    # Save text report
    txt_path = reports_dir / f"{report_name}.txt"
    with open(txt_path, 'w', encoding='utf-8') as f:
        f.write("=" * 60 + "\n")
        f.write("üîç Multi-Language Security Analysis\n")
        f.write("=" * 60 + "\n\n")
        f.write(f"Directory: {directory}\n")
        f.write(f"Timestamp: {timestamp}\n")
        f.write(f"Model: TypeScript V2 (Context-Aware)\n\n")
        
        f.write("=" * 60 + "\n")
        f.write("üìä ANALYSIS SUMMARY\n")
        f.write("=" * 60 + "\n")
        f.write(f"Files analyzed: {len(results)}\n")
        f.write(f"Safe: {safe_count} ({safe_count/len(results)*100:.1f}%)\n")
        f.write(f"Vulnerable: {vuln_count} ({vuln_count/len(results)*100:.1f}%)\n")
        f.write(f"Unsupported: {unsupported_count}\n\n")
        
        f.write("=" * 60 + "\n")
        f.write("üìã DETAILED RESULTS\n")
        f.write("=" * 60 + "\n\n")
        
        for result in results:
            status_icon = "‚úÖ" if result['classification'] == 'SAFE' else ("‚ùå" if result['classification'] == 'VULNERABLE' else "‚ö†Ô∏è")
            f.write(f"{status_icon} {result['file']}\n")
            f.write(f"   Language: {result['language']}\n")
            f.write(f"   Classification: {result['classification']}\n")
            f.write(f"   Confidence: {result['confidence']:.2f}%\n")
            
            if result['vulnerabilities']:
                f.write(f"   Vulnerabilities:\n")
                for vuln in result['vulnerabilities']:
                    f.write(f"      - {vuln}\n")
            f.write("\n")
    
    print(f"\nüìÑ Reports saved:")
    print(f"   JSON: {json_path}")
    print(f"   Text: {txt_path}")
    
    if all_safe:
        print("\n‚úÖ ANALYSIS PASSED - All code is safe")
        print("=" * 60)
        sys.exit(0)
    else:
        print("\n‚ùå ANALYSIS FAILED - Vulnerabilities detected")
        print("=" * 60)
        sys.exit(1)


if __name__ == '__main__':
    main()
